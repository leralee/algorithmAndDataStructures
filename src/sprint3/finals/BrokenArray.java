package sprint3.finals;//№88752111

/**
 * @author valeriali on {01.07.2023}
 * @project algorithms
 */

/**
 Принцип работы алгоритма:

 Алгоритм основан на модифицированной версии бинарного поиска и может найти элемент k в поврежденном
 отсортированном массиве. Алгоритм работает на предположении, что массив был отсортирован перед повреждением.
 Он сравнивает элементы массива с опорным элементом и сокращает интервал поиска в зависимости
 от соответствующих условий, чтобы найти искомый элемент.

 1) Изначально задаются два указателя: left указывает на начало массива, а right указывает на конец массива.
 2) В цикле выполняется поиск элемента k, сокращая интервал поиска в два раза на каждой итерации.
 3) На каждой итерации сравнивается элемент arr[mid] с искомым элементом k.
 4) Если arr[mid] равен k, то возвращается индекс mid, искомый элемент найден.
 В противном случае, проверяется условие arr[mid] >= arr[left] для определения,
 в какой половине массива находится опорный элемент.
 Если это условие выполняется, то проверяется условие arr[left] <= k && arr[mid] > k,
 и интервал поиска сокращается в левой половине массива путем изменения right = mid - 1.
 Если условие arr[mid] >= arr[left] не выполняется, то проверяется условие arr[right] >= k && arr[mid] < k,
 и интервал поиска сокращается в правой половине массива путем изменения left = mid + 1.
 Шаги 1-4 повторяются, пока интервал поиска не сократится до одного элемента или пока не будет найден элемент k.
 Если элемент k не найден, возвращается -1.

 Оценка временной сложности:

 Временная сложность алгоритма бинарного поиска составляет O(log n).
 Каждый шаг сокращает интервал поиска в два раза, пока не будет найден элемент k или
 пока интервал не будет сокращен до одного элемента.

 Оценка пространственной сложности:

 Пространственная сложность алгоритма составляет O(1), так как используется
 только константное количество дополнительной памяти для хранения указателей left, right и mid.
 Алгоритм выполняет поиск в исходном массиве, не требуя дополнительной памяти
 для хранения дополнительных структур данных.
 */

public class BrokenArray {
    public static int brokenSearch(int[] arr, int k) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right){
            int mid = (left + right) / 2;
            if (arr[mid] == k) {
                return mid;
            } else if (arr[mid] >= arr[left]){
                if (arr[left] <= k && arr[mid] > k) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (arr[right] >= k && arr[mid] < k) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }

    private static void test() {
        int[] arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
        assert 6 == brokenSearch(arr, 5);
    }

    public static void main(String[] args) {
        test();
    }

}
